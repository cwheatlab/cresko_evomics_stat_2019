#### AN INTRODUCTION TO GETTING STARTED WITH THE BASICS IN R
####TO BEGIN, ANYTHING THAT FOLLOWS A '#' SYMBOL (AKA HASHTAG) IS JUST FOR YOUR OWN UNDERSTANDING


# Let's start with a simple command that shows the immediate results but the data are not stored.
4*4
(4+3)*2^2


# A better way to do this is to assign variables
# Variables are assigned values using the "<-" operator.
# Variable names must begin with a letter, but other than that, just
# about anything goes.

x <- 2
x * 3
y <- x * 3
3y <- 3                # no good.


# Arithmetic operations can be performed easily on functions as well as numbers. Try the following, and then your own.
# Note that the last of these - 'log' - is a built in function of R, and therefore the object of the function needs to be put in parentheses
# These parentheses will be important, and we'll come back to them later when we add arguments after the object in the parentheses

x + 2
x^2
log(x)


# the outcome of calculations can be assigned to new variables as well, and the results can be checked using the 'print' command

y <- 67
print(y)
x <- 124
z <- (x*y)^2
print(z)


# variables and operations can be performed on characters as well. 
# Note that characters need to be set off by quotation marks to differentiate them from numbers
# The c stands for 'concatenate'.
# note that we are using the same variable names as we did previously, which means that we're overwriting our previous assignment
# a good rule of thumb is to use new names for each variable, and make them short but still descriptive
x <- "Your Father"
print (x)
y <- 'Your Mother'
print (y)
z <- c(x,y)
print (z)


# In general R thinks in terms of vectors (a list of terms) and it will benefit any R user
# to try to write programs with that in mind, as it will simplify most things
# Vectors can be assigned directly using the 'c()' function and then entering the exact values.

x <- c(2,3,4,2,1,2,4,5,10,8,9)


# many functions exist to operate on vectors. Combine these with your previous variable to see what happens

mean(x)
median(x)
var(x)
sum(x)
length(x)
sample(x, replace = T)


# Getting Help on any function is very easy - just type a question mark and the name of the function
# there are functions for just about anything within R and it is easy enough
# to write your own functions if none already exist to do what you want to do.
# In general, function calls have a simple structure: a function name, a set
# of parentheses and an optional set of parameters to send to the function.
# Help pages exist for all functions that, at a minimum, explain what
# parameters exist for the function.  Help can be accessed a few ways:

help(sample)
?sample
help.search("sample")


# Another way to check on function parameters is with the 'args' function

args(sample)


# Creating vector of new data by entering it by hand can be a drag. However, it is also very easy as well by using the 'seq' function. 
# Try the examples below Can you figure out what the three arguments in the parentheses mean? 
# Try varying the arguments to see what happens. Don't go too crazy with the last one or your computer might slow way down.

p_pop1 <- seq(0.0, 1.0, by = 0.1)
print(p_pop1)
p_pop2 <- seq(1.0, 0.0, by = -0.1)
print(p_pop2)
p2_pop2 <- (p_pop2)*(p_pop2)
print(p2_pop2)

### MAKING NICE PLOTS. 
# So far you've been visualizing just the list of output numbers
# You can visualize all of the variables that you've created using the 'plot' function (as well as a number of more sophisticated plotting functions). 
# What do you think that each of the arguments means for the plot function?
# A cool thing about R is that the options for the arguments make sense. Try making up a different one and see if it works

plot (p_pop1, xlab="time", ylab ="p in population 1", type = "p", col = "red")


# You can also combine plots together into a single figure
par(mfrow=c(3,3))
plot (p_pop1, xlab="time", ylab ="p in population 1", type = "p", col = 'red')
plot (p_pop2, xlab="time", ylab ="p in population 2", type = "p", col = 'red')
plot (p2_pop2, xlab="time", ylab ="p2 in population 2", type = "p", col = 'red')
plot (p_pop1, xlab="time", ylab ="p in population 1", type = "l", col = 'blue')
plot (p_pop2, xlab="time", ylab ="p in population 2", type = "l", col = 'blue')
plot (p2_pop2, xlab="time", ylab ="p2 in population 2", type = "l", col = 'blue')
plot (p_pop1, xlab="time", ylab ="p in population 1", type = "b", col = 'green')
plot (p_pop2, xlab="time", ylab ="p in population 2", type = "b", col = 'green')
plot (p2_pop2, xlab="time", ylab ="p2 in population 2", type = "b", col = 'green')


# Data can be generated by being sampled from nearly any distribution

# Binomial Distribution
# function rbinom takes three parameters
#  1. The number of observations to generate
#  2. The number of trials for each observation
#  3. Probability of a success

b <- rbinom(n=100, size=20, prob=0.5)
hist(b)


# This kind of statement can be run in one line as well,

hist(rbinom(n=100, size=20, prob=0.5))


# You can even set up a vector of values that you feed into a distribution function to see the output
x <- seq(0,100,by=1)
y <- dbinom(x,100,0.6)
plot(x,y)


# Poisson Distribution
# function rpois takes two parameters
#  1. The number of observations to generate (random numbers)
#  2. The mean value of observations

r <- rpois(n=100, lambda=1)
hist(r)


# Normal Distribution
# function rnorm takes three parameters
#  1. the number of observations to return
#  2. The mean of the population
#  3. The standard deviation of the population

n <- rnorm(n=100, mean=10, sd=4)
hist(n)


# you can have more than plot in a single figure. Try the following and see what happens
Y <- rnorm(1000, 0, 10)
hist(x, xlim = c(-50,50))
curve(5000*dnorm(x, 0, 10), xlim = c(-50,50), add=TRUE, col="blue")


