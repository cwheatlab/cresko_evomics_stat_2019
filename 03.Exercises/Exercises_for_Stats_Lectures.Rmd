---
title: "Student Exercises | Statistics for Genomics"
output: html_document
author: your name here 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
```

## _Exercise 3.1: Examining Binomially Distributed Data_
1. Using R, simulate the following experimental data: 
  - use the `rbinom()` function to create a new, simulated data set
  - look at the arguments to see how they relate to the trials, probability of each trial, and number of replicates using tab complete or help- then assign each argument based on 20 observations of a fair coin toss
  - use the `hist()` function to plot your simulated data
  - what do the y- and x-axes represent?
  - what is the most common outcome, in terms of the number of “successes” per trial? Does this make sense?
2. Now, vary the `probability` argument to reflect an unfair coin toss
3. Now, change your script to do the following:
  - perform 200 trials for each of the 100 replicates
  - perform 2000 trials for each of the 100 replicate
  - how do the distributions change when you go from 20 to 200 to 2000 trials?
  - what happens to the curve as your probability of "success" gets smaller or larger than 0.5?
    
    
_______________________________


## _Exercise 3.2: An example of creating your own function to model forward and reverse mutation equilibrium_

Populations of organisms constantly experience mutations, often in opposing directions for the same genes. For example, some mutations may create a new function, whereas others destroy that function. The relative rates of those mutations will determine the equilibrium frequencies of the wild type and mutant alleles in a population. Below is a function, defined using `R`, to calculate that equilibrium frequency over time. The values for the different forward and reverse mutations, starting frequencies, and generations for the simulation are initialized in the first line of the script. Change those values in the last line to see how they affect the equilibrium frequency in the population. Can you determine how those values are utilized during the calculations of the equilibrium allele frequencies over time in the function that you defined? Try changing aspects of the function to see what happens to the output.

```{r}
forward_reverse_mutation <- function(forward = 0.00, reverse = 0.00, start_freq = 0.5, generations = 1000)

{
	freq <- start_freq + (1-start_freq)*forward - start_freq*reverse
	freq_array = NULL
	freq_array <- rbind(freq_array, start_freq, freq)
		
	for (j in 1:generations) {
 		freq <- freq + (1-freq)*forward - freq*reverse
		freq_array <- rbind(freq_array, freq)	
			}

matplot (freq_array, xlab="generations", ylab="Equilibrium frequency of the A1 allele", ylim=c(0:1.0), type="l", col = 1:20)
legend(600, 1, start_freq, col = 1:20, lty = 1:20)

}

forward_reverse_mutation(forward = 0.01, reverse = 0.01, start_freq = seq(0.0, 1.0, by = 0.1), generations = 1000)
```

1. How does the relative magnitude of forward and reverse mutations affect your final allele frequency once your population reaching equilibrium? What if the rates are equal? What if they are largely different?
2. How does the magnitude of your mutation rates affect time to equilibrium? What happens if they are very small? Very large?
3. How does the start frequency of A1 allele factor into both time to equilibrium and magnitude of frequency change when your mutation rates are equal? What about when they are not equal?



_______________________________


## _Exercise 3.3: Parametric t-test in R_

1. Using R to make a dummy data set that contains one continuous and one categorical value with two levels. To do so draw individuals of the two different factor levels from normal distributions (check the 'norm' family of functions) with slightly different means but equal standard deviations. Take 100 observations per factor level. 

2. Now, perform a t-test to see if the two populations are statistically different from one another (see below)

```{r, eval=FALSE, echo=TRUE}
boxplot(continuous_variable~cat_variable, dataset name) 
t.test(continuous_variable~cat_variable, dataset name) 
```

3. Repeat steps 1 and 2 above but use different sample sizes (e.g. 10 , then 100, then 1000, then 10,000 obsv. per factor level). How does the sample size affect the statistics?
4. What if you run the test again and  make the means of the categorical groups more dissimilar? 
5. What happens if you change the standard deviation of your normal distributions to be very small or very large?  



_______________________________


## _Exercise 3.4: Test for Hardy-Weinberg Equilibrium in a two-allele model using a Chi-square statistical distribution_

Another common statistical scenario is to test whether counts in different categories of variables are random or not. A good example is the combination of alleles into genotypes in a diploid, sexually reproducing population. This so-called Hardy-Weinberg Equilibrium (HWE) expectation is simply a statement that the choice of each allele is an independent random event (note that this is equivalent to the binomial expectation for two independent events). Therefore, the null expectation under random mating and lack of strong selection is that the genotypes will be predicted by the binomial sampling of alleles based upon their frequencies. We can test against these expectations using the Chi-square statistic. Below modify the counts of genotypes to see how this affects your conclusion as to whether the population is in HWE.

```{r}
# initial genotype frequencies
AA_counts <- 11
Aa_counts <- 43
aa_counts <- 0
```


```{r}
# total number of alleles, allele frequencies and probabilities
num.alleles <- 2*sum(AA_counts,Aa_counts,aa_counts)
num.a.alleles <- 2*aa_counts + Aa_counts
num.A.alleles <- 2*AA_counts + Aa_counts
p <- num.A.alleles / num.alleles
q <- num.a.alleles / num.alleles
```


```{r}
# Expected genotype probabilities in the F1
expected.AA <- p^2
expected.Aa <- 2 * p * q
expected.aa <- q^2
# Expected genotype frequencies in the F1
E.AA <- expected.AA * num.alleles/2
E.Aa <- expected.Aa * num.alleles/2
E.aa <- expected.aa * num.alleles/2
```

```{r}
# Calculate the chi squared statistic
chi.sq <- ((AA_counts-E.AA)^2 - E.AA) / E.AA  +
          ((Aa_counts-E.Aa)^2 - E.Aa) / E.Aa  +
          ((aa_counts-E.aa)^2 - E.aa) / E.aa 
print(chi.sq)
```

- You've calculated the observed Chi-square value above
- To calculate the p-value associated for this statistic with 2 degrees plug into the equation below with the observed chi-square (as occurs here)
- Significant p-values (< 0.05) mean that the population deviates from HWE

```{r}
1- pchisq(chi.sq,df = 2)
```

- Based on these result, do you reject or fail to reject the null hypothesis? What was your alpha level?





_______________________________


## _Exercise 4.1: Linear models to examine the relationship of different hormone levels and thyroid morphology in zebrafish_

Write a code chunk to read in the 'perchlorate2.csv' data set in the data folder. This file includes data from a test in which multiple strains of zebrafish were exposed to multiple concentrations of the toxic compound perchlorate, which interferes with thyroid development and function. Several outcomes of fish thyroid morphology and hormone concentration were measured. 

1. The data set includes the following variables in this order:

- Strain of zebrafish (categorical)
- Perchlorate_Level	(continuous)
- T4_Hormone_Level	(continuous)
- Follicle_Area	(continuous)
- Number_of_Follicles	(count)
- Age_dpf (continuous)
- Age_Category	(categorical)
- Testes_Area	(continuous)
- Testes_StageNow (categorical)

2. Modify the code below to build a linear model of two **continuous** variables. You can check for variable class using `str`.  
  - What is the response? What is the predictor?
  - Notice how the output of the linear model is specified to a new object.
  
```{r, echo=TRUE, eval=FALSE}
my_lm <- lm(XXX ~ YYY)
```

- Now look at a summary of the linear model

```{r, echo=TRUE, eval=FALSE}
summary(my_lm)
print(my_lm)
```

3. Now let's produce a regression plot

```{r, echo=TRUE, eval=FALSE}
plot(XXX~YYY, col = “blue”)
abline(my_lm, col = “red”)
```
 
  - What does the line represent?

4. You can use the `$` operator to select out parameter values and estimates from your model object. Plot the residuals over the fitted values by extracting them from your model object.   
  - Are there any obvious patterns in this plot?
  - What happens when you `plot` the linear model object itself?
  - Using these plots, does it appear that you have violated any assumptions?









_______________________________


## _Exercise 4.2: 2-by-2 fixed effect factorial ANOVA examining the effects of microbiome treatment on RNA expression levels in the guts of threespine stickleback_

Load the RNAseq_microbiome.csv dataset which represents RNAseq data collected for three different genes (FGF3, Sox10 and SLC5) from the guts of threespine stickleback fish. In this experiment two different genotypes of stickleback (ocean and freshwater) were tested by subjecting each to two different microbiome treatments (conventional or mono-associated). Stickleback can be made germ free and then either exposed to the conventional microbiome or just one microbe. After exposure the guts were extracted, RNA isolated, and RNAseq data collected. This data set has just three genes. Is `R` correctly interpreting the class of your variables? It is always good to check this before doing anything. 

1. Make boxplots to graphically illustrate differences in gene expression distributions among genotype and microbiota treatment for each gene.
  - Hint: You may need to create a new variable for this.
  - Any obvious patterns?
  - Would you guess there is a difference among means?
  - Does it look like there may be an interaction?

2. Fit the factorial linear model 
  - Below are two different ways to do the same thing
  - Then use the summary function to look at your results. 

```{r, echo=TRUE, eval=FALSE}
rna_aov <- aov(gene ~ microbiota + genotype + microbiota:genotype)
rna_aov <- aov(gene ~ microbiota*genotype)
```

3. Is there a significant interaction between genotype and treatment?











____________________________________


## _Exercise 4.3: NMDS for the analysis of multivariate data_

Nonmetric Multidimensional Scaling (NMDS) is a form of nonparametric clustering. As such, some of the distributional assumptions of multivariate analyses are relaxed. The package VEGAN was originally derived for ecological data across plots or sites. For example, enumeration of species across different locations. However, the approach is very applicable to genetic data across geographic locals or phenotypes, or gene expression data across different samples. Now examine the 'yeast.tsv' data set, which is a measurement of RNAseq levels of numerous genes from six different yeast samples from different vineyards.

```{r, eval=TRUE, echo=TRUE}
library (vegan)
yeast_data <- read.table('data/yeast.tsv', row.names = 1, header = T, sep = '\t')
```

1. We'll first turn the raw data matrix into a dissimilarity matrix for all samples. The `decostand` function is a form of normalization.

```{r}
vare.dis <- vegdist(decostand(yeast_data, "hell"), "euclidean")
#print (vare.dis)
```

2. Now we'll perform the clustering of the samples using multidimensional scaling. The goal of this is to represent complex data in lower dimensions without losing too much information. Take a look at the 'stress' values of moving from a higher to lower dimensionality of the data. Usually a value of 0.15 or lower is considered acceptable and indicates a good model fit.


```{r}
vare.mds0 <- monoMDS(vare.dis)
print (vare.mds0)
```

3. Let's take a look at how the dissimilarities among samples maps onto the ordination distance. Notice that there is a fit with the data, but we're no longer assuming consistent linearity over the entire data set.

```{r}
stressplot(vare.mds0, vare.dis)
```

- What does the R^2 value tell you? Is the model accurately predicting the observed dissimilarity?


4. Now let's look at the grouping of the samples in this lower dimensional space. 

```{r}
ordiplot (vare.mds0, type = "t")
```

- Any clustering?

5. Now we can rerun the ordination and add all of the data (genes) as well to the plot.

```{r}
vare.mds <- metaMDS(yeast_data, trace = F)
plot (vare.mds, type = "t")
```

- How does this plot compare to your first plot? What's all that red stuff?

6. We can run a PCA on our data as well, which is a *metric* analysis that utilizes Euclidean distances

```{r}
vare.pca <- rda(yeast_data, scale = TRUE)
print (vare.pca)
```

- What do you notice about the eignevalues of the PCs? 
- How many original variables were there? How many eigenvectors will there be?
- Showing both the locations of the samples and the variables. 
- Try different plots that show one or the other or both

```{r}
plot (vare.pca, scaling = -1)
plot (vare.pca, scaling = 1)
plot (vare.pca, scaling = 2)
```

- What are these plots showing? What does that scaling argument do?
- What is in red? What is in black?

```{r}
biplot (vare.pca, scaling = -1)
biplot (vare.pca, scaling = 1)
```

7. Lastly, we can use the dissimilarity matrices to perform hierarchical clustering. Try both the non-normalized (clus.dis1) and normalized (clus.dis2) distances.

```{r}
clus.dis1 <- vegdist(yeast_data)
clus.dis2 <- vegdist(decostand(yeast_data, "hell"), "euclidean")
```

```{r}
cluster1 <- hclust(clus.dis1, "single")
plot(cluster1)
```

Now, try these different versions of clustering. What is different about them?

```{r}
cluster_complete <- hclust(clus.dis1, "complete")
plot(cluster_complete)
```

```{r}
cluster_average <- hclust(clus.dis1, "average")
plot(cluster_average)
```

7. Lastly, let's ask R to cut the tree into several clusters for us. I've written it as three. Try it with different numbers of clusters and the different types of clustering from above.

```{r}
grp <- cutree(cluster1, 4)
print (grp)
```


________________________________________


## _Exercise 4.4: Biodiversity analysis in R - pulling it all together_

This last exercise comes to us thanks to the hard work of Steven Kembel, who is a faculty member at the University of Montreal in Canada. Steve was a postdoctoral scholar at the University of Oregon and put together this very nice exercise to demonstrate how to pull numerous different R packages and scripts together into an integrated data analysis pipeline. The purpose of this particular script is to examine the biodiversity of grassland plants in ecological communities in Canada using several common ecological statistics. You are participating in a workshop on genomics, so might wonder how this applies to you. An amazing convergence in understanding has occurred over the past decade by recognizing that analyses of the distributions and abundances of macro-organisms, micro-organisms and gene transcripts across different samples (e.g. environments, body sites or cell types) are all very similar. Therefore, the workflow that you learn here can be applied to numerous biological problems you might encounter in the future regarding when, where and how much biological units occur across various units. 

## General background

In this exercise we are going to analyze a data set on the biodiversity of grassland plants in Alberta. This data set consists of data on the occurrence of grassland plants at several different sites in Alberta, along with information on their functional traits and phylogenetic relationships.

Dr. Kembel described this data set in more detail in the following paper:
S.W. Kembel and J.F. Cahill, Jr. 2011. Independent evolution of leaf and root traits within and among temperate grassland plant communities. PLoS ONE 6(6): e19992. (doi:10.1371/journal.pone.0019992).

# Getting everything set

To begin, make sure you have loaded the picante package and the workspace image that contains all of the data files by running the following commands.

```{r eval=FALSE}
load("R_biodiversity_workspace.RData")
```

# Getting biodiversity data into R

The first thing we need to do is import all the data we need into R.

We will want to make sure the different packages we are going to use are loaded. We will be using functions from the **ape**, **picante**, and **vegan** packages today. Since **picante** depends on the other two packages, loading it will load the other two as well.

```{r, echo=FALSE}
library(picante)
```

## Community data

Ecological community data consist of observations of the (relative) abundance of species in different samples. In our case, the abundance measure is percent cover of different plant species in 20x20m quadrats in grasslands in different habitat types.

The format for community data is a data.frame with samples in the rows and species in the columns. Our data are already in this format so we can load them using the following command. Note that since we've set our working directory to the folder containing all the data files, we just have to type the filename.

```{r}
# read community data
# use plot IDs as rownames (first column of data)
# use species names as colnames (default read.csv is header=TRUE)
# replace filename with file.choose() to open interactive window
comm <- read.csv("data/grassland.community.csv", header=TRUE, row.names=1)
```

By reading the data in this way, we have set the species names as the column names, and the sample names as the row names. This is important to note - we didn't load these labels in as data - they are the *names* of the rows/columns. Later this will make it easier for us to link different data sets. Let's check to make sure our rows and columns have reasonable-looking names.

```{r}
class(comm)
# get the dimension of the community object (rows x columns)
dim(comm)
rownames(comm)
head(colnames(comm))
# take a peek at the data (just the first five rows/columns)
comm[1:5, 1:5]
```

Each cell contains the percent cover of a species in a sample (there is a file in the 'data' folder that lists all of the names of the different plant species). Many multivariate methods are sensitive to the total abundance in a sample, so we should probably convert these absolute abundance estimates to a relative abundance estimate. We can do this with a function from the **vegan** package.

```{r}
# check total abundance in each sample
apply(comm, 1, sum)
# Turn percent cover to relative abundance by dividing each value by sample total abundance
comm <- decostand(comm, method="total")
# check total abundance in each sample
apply(comm, 1, sum)
# look at the transformed data
comm[1:5, 1:5]
```

## Trait data

We also have information on the leaf and root traits of each species. We can load these data in the same way as the community data, but now we will have species in the rows and traits in the columns.

```{r}
# replace filename with file.choose() to open interactive window
traits <- read.csv("data/species.traits.csv", header=TRUE, row.names=1)
# take a peek at the data
head(traits)
# plot the data
pairs(traits)
# some variables look skewed - log transform all variables
traits <- log10(traits)
# plot the transformed data
pairs(traits)
```

## Metadata

We have some information about the samples, including the habitat and site they were collected from, and a few basic environmental variables such as slope and moisture regime.

```{r}
# replace filename with file.choose() to open interactive window
metadata <- read.csv("data/plot.metadata.csv", header=TRUE, row.names=1)
# take a peek at the data
head(metadata)
```

## Phylogeny

If you have a phylogeny in the commonly used Newick or Nexus format, it can be imported into R with the read.tree or read.nexus functions.

```{r}
# replace filename with file.choose() to open interactive window
phy <- read.tree("data/grassland.phylogeny.newick")
class(phy)
phy
```

Our phylogeny is a special object of type `phylo`. The `phylo` format itself is documented at the **ape** homepage (http://ape.mpl.ird.fr/). A `phylo` object is a special type of `list` object - it has different elements such as tip labels and edge lengths, and R knows how to summarize and plot a `phylo` object due to the way it is defined by the **ape** package.

```{r}
# list the elements of our phylogeny
names(phy)
# what are the first few tip labels?
phy$tip.label[1:5]
# how many tips does our phylogeny have?
Ntip(phy)
# plot our phylogeny (the cex argument makes the labels small enough to read)
plot(phy, cex=0.5)
```

## Cleaning and matching data sets
Our workspace contains the community, trait, phylogeny, and metadata that we will need for our analyses.

```{r}
ls()
```

The data sets we are using today have already been cleaned up so that they contain the same species and the same samples, but often when we are working with our own data, there will be mismatches among different types of data. For example, our community data might only contain a subset of the species in our phylogeny, or there might be some species for which we have trait information but no phylogenetic information. For some analyses, R will assume that species are in the same order in both the community data set and the phylogeny. Sometimes there might be a typo in the labels for a dataset, and we will want to catch those before proceeding.

There are several functions in **picante** that are designed to make sure different data sets match with one another. We should check that our phylogeny and community contain the same species, and that they are in the same order. The `match.phylo.comm` takes a community object and a phylo object, reports any species that are not present in both data sets, and outputs a version of each object in the same order and containing the same species.

```{r}
# check for mismatches/missing species
combined <- match.phylo.comm(phy, comm)
# the resulting object is a list with $phy and $comm elements.
# replace our original data with the sorted/matched data
phy <- combined$phy
comm <- combined$comm
```

We should do the same matching for our trait data.

```{r}
combined <- match.phylo.data(phy, traits)
# the resulting object is a list with $phy and $data elements.
# replace our original data with the sorted/matched data
phy <- combined$phy
traits <- combined$data
```

We should also check whether our community data and metadata are in the same order.

```{r}
all.equal(rownames(comm), rownames(metadata))
# they all match - if they didn't we could sort them to the same order
# sort metadata rows to be in the same order as community rows
metadata <- metadata[rownames(comm), ]
```

We're done! All of our data are now ready for analysis. In each of the sections below we will explore different ways of analyzing the biodiversity of plants in these grasslands.

# Visualizing and summarizing biodiversity data

## Community richness and diversity

At a most basic level, we can ask about the overall taxonomic diversity of these grasslands. How many plant species are there? Do habitats differ in species richness?

```{r fig.width=4,fig.height=4}
# compare species richness between fescue and mixedgrass habitats
boxplot(specnumber(comm) ~ metadata$habitat, ylab="# of species")
# statistical test of difference
t.test(specnumber(comm) ~ metadata$habitat)
```

Did we do a good job of sampling the diversity that is out there? We can look at a collector's curve to assess this. What do you conclude, based on the graph?

```{r fig.width=5,fig.height=5}
# plot species accumulion curve across samples
plot(specaccum(comm), xlab="# of samples", ylab="# of species")
```

# Multivariate community analysis

- How does the composition of plant communities vary across different samples? 
- How are habitat type and environmental variables related to plant community composition?

We can use multivariate ordination methods to explore community structure in more detail. These methods are available in the **vegan** package, which also includes excellent documentation and tutorials for these methods. The book "Numerical Ecology in R" by Borcard et al. gives a great overview of multivariate analysis methods.

## Hierarchical clustering

We can cluster together plots based on their overall community composition. We will calculate Bray-Curtis dissimilarity among all the samples, an abundance-weighted measure of how dissimilar two communities are in terms of their species composition. We will then cluster together communities that are similar using an agglomerative hierarchical clustering algorithm.

```{r}
# calculate Bray-Curtis distance among samples
comm.bc.dist <- vegdist(comm, method="bray")
# cluster communities using average-linkage algorithm
comm.bc.clust <- hclust(comm.bc.dist, method="average")
# plot cluster diagram
plot(comm.bc.clust, ylab="Bray-Curtis dissimilarity")
```

What does your plot tell you about whether the two habitats contain different plant communities?

## Ordination

There are numerous ordination methods available in R. For now, let's use non-metric multidimensional scaling (NMDS) again to visualize the multivariate structure of these communities.

```{r fig.width=4,fig.height=4}
# The metaMDS function automatically transforms data and checks solution robustness
comm.bc.mds <- metaMDS(comm, dist="bray")
# Assess goodness of ordination fit (stress plot)
stressplot(comm.bc.mds)
```

We can plot the ordination results in a variety of different ways.

```{r}
# plot site scores as text
ordiplot(comm.bc.mds, display="sites", type="text")
# automated plotting of results - tries to eliminate overlapping labels
ordipointlabel(comm.bc.mds)
# ordination plots are highly customizable
# set up the plotting area but don't plot anything yet
mds.fig <- ordiplot(comm.bc.mds, type="none")
# plot just the samples, colour by habitat, pch=19 means plot a circle
ordipointlabel(mds.fig$sites, "sites", pch=19, col="green", select=metadata$habitat=="Fescue")
ordipointlabel(mds.fig, "sites", pch=19, col="blue", select=metadata$habitat=="Mixedgrass")
# add confidence ellipses around habitat types
ordiellipse(comm.bc.mds, metadata$habitat, conf=0.95, label=TRUE)
# overlay the cluster results we calculated earlier
ordicluster(comm.bc.mds, comm.bc.clust, col="gray")
```

We can also visualize the abundance of species. The `ordisurf` function fits a smooth surface to estimates of species abundance.

```{r message=FALSE,fig.width=5,fig.height=4,warning=FALSE}
# plot Sphaeralcea abundance. cex increases the size of bubbles.
ordisurf(comm.bc.mds, comm[,"Sphaeralcea_coccinea"], bubble=TRUE, main="Sphaeralcea coccinea abundance", cex=3)
```

### Adding environmental and trait data to ordinations

How are environmental variables correlated with the ordination axes?

```{r}
ordiplot(comm.bc.mds)
# calculate and plot environmental variable correlations with the axes
# use the subset of metadata that are environmental data
plot(envfit(comm.bc.mds, metadata[,3:6]))
```

It is also possible to do a constrained ordination such as constrained correspondence analysis (CCA) or redundancy analysis (RDA), where trait or environmental data are incorporated directly into the ordination. These methods are implemented in the functions `cca` and `rda` in **vegan**.

# Trait evolution

## Phylogenetic signal

The idea of phylogenetic niche conservatism (the ecological similarity of closely related species) has attracted a lot of attention, for example in the widely used framework of inferring community assembly processes based on knowledge of community phylogenetic structure plus the phylogenetic conservatism of traits. (Webb et al. 2002).

Phylogenetic signal is a quantitative measure of the degree to which phylogeny predicts the ecological similarity of species. The K statistic is a measure of phylogenetic signal that compares the observed signal in a trait to the signal under a Brownian motion model of trait evolution on a phylogeny (Blomberg et al. 2003). K values of 1 correspond to a Brownian motion process, which implies some degree of phylogenetic signal or conservatism. K values closer to zero correspond to a random or convergent pattern of evolution, while K values greater than 1 indicate strong phylogenetic signal and conservatism of traits. The statistical significance of phylogenetic signal can be evaluated by comparing observed patterns of the variance of independent contrasts of the trait to a null model of shuffling taxa labels across the tips of the phylogeny. These tests are implemented in the `Kcalc`, `phylosignal`, and `multiPhylosignal` functions.

Let's measure phylogenetic signal in these data.

```{r}
# one way to do it - apply the Kcalc function to each column of the data.frame
apply(traits, 2, Kcalc, phy)
# another way to do it with significance testing
# we have to convert the tree to be dichotomous before calculating P-values
multiPhylosignal(traits, multi2di(phy))
```

In the output, `K` is the K statistic (magnitude of signal vs. Brownian motion), and `PIC.variance.P` is the P-value of the test for non-random signal. Most variables show more phylogenetic signal than expected by chance.

## Visualizing trait evolution

We can visualize trait values on the phylogeny by plotting a different color or size of symbol for each trait value. Let's visualize leaf area, the trait with the strongest phylogenetic signal. The cex argument to the tiplabels function adjusts the size of the trait symbols - some tinkering around with the scaling of the symbol sizes is required depending on the trait.

```{r}
# Plot phylogeny facing upwards. Show node labels but not tip labels. cex shrinks labels.
plot(phy, direction="up", show.tip.label = FALSE, show.node.label=TRUE, cex=0.7)
# Plot leaf area on the phylogeny. cex argument scales symbol size by trait value.
tiplabels(pch = 19, col="black", cex = 3*(traits[,"LeafArea"] / max(traits[,"LeafArea"])))
```

## Phylogenetic analysis of trait relationships

Phylogenetic signal means that closely related species have similar traits. This violates the assumption of independence of data points that is inherent in many methods including correlation and regression (Felsenstein 1985). We can account for non-independence due to phylogenetic signal using methods including phylogenetically independent contrasts and phylogenetic generalized least squares (pGLS).

Generalized least squares methods work just like an ANOVA or linear model - we can test for relationships between categorical or continuous values, optionally taking phylogenetic relatedness into account.

Let's test for a relationship between specific root length (SRL) and root tissue density, taking phylogenetic relationships among species into account.

```{r}
# GLS of root tissue density as a function of SRL - non-phylogenetic model
root.gls <- gls(RootTissueDens ~ SRL, data=traits)
anova(root.gls)
# Phylogenetic GLS - adds effect of phylogeny to the model
root.pgls <- gls(RootTissueDens ~ SRL, correlation=corBrownian(value=1,phy), data=traits)
anova(root.pgls)
# plot relationship
plot(RootTissueDens ~ SRL, data=traits, xlab="SRL (specific root length)", ylab="Root tissue density")
# add model fit lines - coef is the model fit coefficients, lwd increases line width
abline(coef(root.gls), lwd=2, col="black")
abline(coef(root.pgls), lwd=2, col="red")
legend("bottomleft", legend=c("GLS fit","Phylogenetic GLS fit"), lwd=2, col=c("black","red"))
```

There is a weak relationship between SRL and root tissue density. The relationship is not significant if we do not take phylogenetic relatedness into account. We see a stronger and significant relationship between SRL and root tissue density after taking phylogenetic relatedness into account.

# Phylogenetic and trait diversity

## Phylogenetic diversity

One of the earliest measures of phylogenetic relatedness in ecological communities was the phylogenetic diversity (PD) index proposed by Faith. Faith's PD is defined as the total branch length spanned by the tree including all species in a local community, optionally including the root node of the phylogeny. The `pd` function returns two values for each community, Faith's PD and species richness (SR).

```{r fig.width=4,fig.height=4}
# Calculate Faith's PD
comm.pd <- pd(comm, phy)
head(comm.pd)
# Plot Faith's PD by habitat
boxplot(comm.pd$PD ~ metadata$habitat, xlab="Habitat", ylab="Faith's PD")
# Test for PD differences among habitats
t.test(comm.pd$PD ~ metadata$habitat)
# Compare PD and species richness
plot(comm.pd$PD ~ comm.pd$SR, xlab="Species richness", ylab="Faith's PD")
```

Faith's PD is lower in mixedgrass habitats than in fescue habitats. But Faith's PD is highly correlated with species richness, and we already know that there are fewer species in mixedgrass habitats, so we need some way to compare phylogenetic diversity that takes this fact into account.

### $MPD$, $MNTD$,  $SES_{MPD}$ and $SES_{MNTD}$

Another way of thinking about the phylogenetic relatedness of species in a community is to ask 'how closely related are the average pair of species or individuals in a community', and relate the patterns we observe to what we'd expect under various null models of evolution and community assembly. These types of questions are addressed by the measures of community phylogenetic structure such as MPD, MNTD, NRI and NTI described by Webb et al. and implemented in Phylocom.

The function `mpd` will calculate the mean pairwise distance between all species or individuals in each community. Similarly, the `mntd` function calculates the mean nearest taxon distance, the average distance separating each species or individual in the community from its closest heterospecific relative. The `mpd` and `mntd` functions differs slightly from the `pd` function in that they take a distance matrix as input rather than a phylogeny object. A `phylo` object can be converted to a interspecific phylogenetic distance matrix using the `cophenetic` function. Since the mpd and mntd functions can use any distance matrix as input, we can easily calculate trait diversity measures by substituting a trait distance matrix for the phylogenetic distance matrix. We'll return to this idea shortly.

If the community data represent abundance measures, the abundance data can be taken into account. Doing so changes the interpretation of these metrics from the average distance among two randomly chosen species from a community, to the average distance among two randomly chosen individuals in a community.

Measures of 'standardized effect size' of phylogenetic community structure can be calculated for MPD and MNTD by compared observed phylogenetic relatedness to the pattern expected under some null model of phylogeny or community randomization. Standardized effect sizes describe the difference between average phylogenetic distances in the observed communities versus null communities generated with some randomization method, standardized by the standard deviation of phylogenetic distances in the null data:

$SES_{metric} =  \frac{ Metric_{observed} - mean(Metric_{null}) }{sd(Metric_{null})}$

Phylocom users will be familiar with the measures NRI and NTI; $SES_{MPD}$ and $SES_{MNTD}$ are equivalent to -1 times NRI and NTI, respectively. Several different null models can be used to generate the null communities. These include randomizations of the tip labels of the phylogeny, and various community randomizations that can hold community species richness and/or species occurrence frequency constant. These are described in more detail in the help files, as well as in the Phylocom manual. Let's calculate some of these measures of community phylogenetic structure for our example data set. We will ignore abundance information, and use a simple null model of randomly drawing species while keeping sample species richness constant.

```{r}
# convert phylogenety to a distance matrix
phy.dist <- cophenetic(phy)
# calculate ses.mpd
comm.sesmpd <- ses.mpd(comm, phy.dist, null.model="richness", abundance.weighted=FALSE, runs=999)
head(comm.sesmpd)
# calculate ses.mntd
comm.sesmntd <- ses.mntd(comm, phy.dist, null.model="richness", abundance.weighted=FALSE, runs=999)
head(comm.sesmntd)
```

The output includes the following columns:

* `ntaxa` - Number of taxa in community
* `mpd.obs` - Observed mpd in community
* `mpd.rand.mean` - Mean mpd in null communities
* `mpd.rand.sd` - Standard deviation of mpd in null communities
* `mpd.obs.rank` - Rank of observed mpd vs. null communities
* `mpd.obs.z` - Standardized effect size of mpd vs. null communities (equivalent to -NRI)
* `mpd.obs.p` - P-value (quantile) of observed mpd vs. null communities (= mpd.obs.rank / runs + 1)
* `runs` - Number of randomizations

Positive SES values (mpd.obs.z > 0) and high quantiles (mpd.obs.p > 0.95) indicate phylogenetic evenness, while negative SES values and low quantiles (mpd.obs.p < 0.05) indicate phylogenetic clustering, relative to the null model. MPD is generally thought to be more sensitive to tree-wide patterns of phylogenetic clustering and eveness, while MNTD is more sensitive to patterns of evenness and clustering closer to the tips of the phylogeny. 

```{r fig.height=4,fig.width=4}
# compare ses.mpd between habitats
plot(comm.sesmpd$mpd.obs.z ~ metadata$habitat, xlab="Habitat", ylab="SES(MPD)")
abline(h=0, col="gray")
t.test(comm.sesmpd$mpd.obs.z ~ metadata$habitat)
# compare ses.mntd between habitats
plot(comm.sesmntd$mntd.obs.z ~ metadata$habitat, xlab="Habitat", ylab="SES(MNTD)")
abline(h=0, col="gray")
t.test(comm.sesmntd$mntd.obs.z ~ metadata$habitat)
```

It looks like plant communities from fescue habitats are phylogenetically even more distantly related than expected by chance, ($SES > 0$), and communities from mixedgrass habitats are phylogenetically clustered (more closely related than expected by chance, $SES < 0$).

Let's look at the distribution of species from samples in these different habitats on the phylogeny. Fescue community 'fes-K-11' contains species that are phylogenetically even.

```{r fig.width=4,fig.height=5}
# plot species present in a fescue community
plot(phy, show.tip.label=FALSE, main="Fescue community fes-K-11")
tiplabels(tip = which(phy$tip.label %in% colnames(comm)[comm["fes-K-11",]>0]), pch=19)
```

Mixedgrass community 'mix-H-23' contains species that are phylogenetically clumped.

```{r fig.width=4,fig.height=5}
# plot species present in a mixedgrass community
plot(phy, show.tip.label=FALSE, main="Fescue community mix-H-23")
tiplabels(tip = which(phy$tip.label %in% colnames(comm)[comm["mix-H-23",]>0]), pch=19)
```

## Trait diversity

We can calculate measures of trait diversity within communities in a manner analogous to the methods we used to calculate phylogenetic diversity. Let's calculate the standardized effect size of functional trait diversity by measuring trait dissimilarity among co-occurring species, and comparing observed trait diversity to a null model.

```{r fig.height=4,fig.width=4}
# calculate trait distance - Euclidean distance among scaled trait values - we want the full distance matrix
trait.dist <- as.matrix(dist(scale(traits), method="euclidean"))
# calculate trait ses.mpd
comm.sesmpd.traits <- ses.mpd(comm, trait.dist, null.model="richness", abundance.weighted=FALSE, runs=999)
# compare trait ses.mpd between habitats
plot(comm.sesmpd.traits$mpd.obs.z ~ metadata$habitat, xlab="Habitat", ylab="Trait SES(MPD)")
abline(h=0, col="gray")
```

In contrast to the pattern we saw for phylogenetic diversity, trait diversity is lower than expected in both habitats ($SES_{MPD} < 0$), indicating that co-occurring plants have similar leaf and root traits, and this pattern of trait clustering is stronger in mixedgrass habitats.

The `treedive` function in **vegan** calculates a measure of functional trait diversity that is similar to Faith's PD.

## Phylogenetic beta-diversity

We can measure patterns of phylogenetic relatedness among communities in a manner similar to the within-community phylogenetic diversity measures described above. The `unifrac` and `phylosor` functions measure the among-community equivalent of Faith's PD, the total unique/shared branch length between communities. The `comdist` and `comdistnt` functions measure the among-community equivalent of MPD and MNTD, the mean pairwise distance or mean nearest taxon distance between pairs of species drawn from two distinct communities.

Let's compare a few different ways of measuring dissimilarity among communities. We've already calculated the Bray-Curtis distance among communities based on shared species (`comm.bc.dist`). Since the Bray-Curtis distance incorporates species abundances, we should use abundance information when calculating phylogenetic and trait diversity as well.

```{r}
# calculate phylogenetic MNTD beta diversity
comm.mntd.dist <- comdistnt(comm, phy.dist, abundance.weighted=TRUE)
# calculate functional trait MNTD beta diversity
comm.mntd.traits.dist <- comdistnt(comm, trait.dist, abundance.weighted=TRUE)
# calculate Mantel correlation for taxonomic Bray-Curtis vs. phylogenetic MNTD diversity
mantel(comm.bc.dist, comm.mntd.dist)
# calculate Mantel correlation for taxonomic Bray-Curtis vs. trait MNTD diversity
mantel(comm.bc.dist, comm.mntd.traits.dist)
```

## Phylogeny/trait-based ordinations

Since we can calculate phylogeny- and trait-based measures of dissimilarity among samples, we can also perform an ordination of samples based on these metrics. Let's compare phylogeny- and trait-based ordinations with the species-based ordination we performed earlier.

```{r fig.height=4,fig.width=4,warning=FALSE}
# NMDS ordination of phylogenetic distances - use monoMDS since we only have among-sample distances
comm.mntd.mds <- monoMDS(comm.mntd.dist)
# set up the plotting area but don't plot anything yet
mds.fig <- ordiplot(comm.mntd.mds, type="none")
# plot just the samples, colour by habitat, pch=19 means plot a circle
points(mds.fig, "sites", pch=19, col="green", select=metadata$habitat=="Fescue")
points(mds.fig, "sites", pch=19, col="blue", select=metadata$habitat=="Mixedgrass")
# add confidence ellipses around habitat types
ordiellipse(comm.mntd.mds, metadata$habitat, conf=0.95, label=TRUE)
```

```{r fig.height=4,fig.width=4,warning=FALSE}
# NMDS ordination of trait distances - use monoMDS since we only have among-sample distances
comm.mntd.traits.mds <- monoMDS(comm.mntd.traits.dist)
# set up the plotting area but don't plot anything yet
mds.fig <- ordiplot(comm.mntd.traits.mds, type="none")
# plot just the samples, colour by habitat, pch=19 means plot a circle
points(mds.fig, "sites", pch=19, col="green", select=metadata$habitat=="Fescue")
points(mds.fig, "sites", pch=19, col="blue", select=metadata$habitat=="Mixedgrass")
# add confidence ellipses around habitat types
ordiellipse(comm.mntd.traits.mds, metadata$habitat, conf=0.95, label=TRUE)
```

It looks like fescue and mixedgrass habitats are quite distinct regardless of how we quantify their biodiversity - they contain different species, phylogenetically distinct taxa, and the traits of species in the two habitats are distinct.

## Testing for multivariate differences among groups

We can quantify the relationship between dissimilarity measures and different explanatory variables using the Permutational MANOVA (a.k.a. AMOVA) framework in the `adonis` function in **vegan**. This method allows ANOVA-like tests of the variance in beta diversity explained by categorical or continuous variables.

Let's quantify the degree to which habitat can explain taxonomic, phylogenetic, and trait dissimilarity among grasslands.

```{r}
# Taxonomic (Bray-Curtis) dissimilarity explained
adonis(comm.bc.dist ~ habitat, data=metadata)
# Phylogenetic dissimilarity explained
adonis(comm.mntd.dist ~ habitat, data=metadata)
# Trait dissimilarity explained
adonis(comm.mntd.traits.dist ~ habitat, data=metadata)
```

These results support the pattern we can see visually in the ordination diagrams. These habitats are distinct in terms of their taxonomic, phylogenetic, and functional trait diversity.


